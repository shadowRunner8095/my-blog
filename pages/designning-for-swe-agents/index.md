# Designing for SWE Agents

## Anecdote: My Experience with Jules from Google

Here’s my story: I assigned an issue to **Jules**, an SWE agent from Google.  
It **read my entire codebase** to understand the problem and even attempted to **build the project inside a virtual machine**.

Honestly, that’s impressive—reading the whole project to get context is exactly the kind of behavior I’d want from a coding agent. But this also got me thinking: what if agents had **metadata or navigation hints** to find relevant parts of the code faster?  

Imagine having **tags or pointers** in the repository that guide the agent to specific areas—this could make context gathering and request processing much faster.


## The Challenge with Full VM Builds

Not all problems require spinning up an entire VM with the full project, especially for repositories with **complex dependencies**.  

For example, my issue was with the **navbar animation**: it started with a fade-out effect and glitched. Jules proposed solutions close to the real fix, but to validate them, it still had to **spawn a full VM** and run the entire project.

While **end-to-end (e2e) testing** is indeed the safest approach—since side effects can emerge from unexpected interactions—it’s often overkill for isolated UI or logic bugs. There should be a middle ground.


## A More Efficient Approach: Problem Isolation

We could isolate the problem in a **lightweight environment** with fewer dependencies and less complexity, while still reproducing the relevant behavior.

In my case, this could mean:

1. Creating a **minimal HTML setup** with just a `<div>`, `<label>`, and `<input>`.
2. Reproducing the toggle logic that shows or hides elements when the input is checked.
3. Running this in something like the **TailwindCSS Playground**, which can be launched entirely in the browser via their `play.js` script.

This would allow the agent to quickly **iterate on potential solutions** without the overhead of building the full app.


## From Isolation to E2E Testing

Once the isolated fix works, the agent can **move to an e2e test**.  
In my case, this might still fail if the HTML is generated by a Rust backend binary. That’s fine—the agent can then:

- \- Propose code changes.
- \- Deploy to a **stable development environment**.
- \- Use a **Playwright sandbox** to scrape and test the live app.


## Why E2E Still Matters

Don’t get me wrong—**end-to-end tests are crucial**. Some projects can’t be meaningfully modularized, and a small change in one part can cause issues elsewhere.

But for e2e to be truly effective, they must be **trustworthy**. This means:

- \- Well-maintained test suites.
- \- Clear failure messages.
- \- Minimal flaky tests.


## The Bigger Picture

To get the best out of SWE agents, I believe we need:

- \- **Documentation** – clear descriptions of architecture, workflows, and quirks.
- \- **Prompts and instruction files** – guiding the agent in navigating the code.
- \- **LLM-specific hints** – metadata like tags, hints, and search anchors.
- \- **Robust automated tests** – including both isolated and e2e tests.
- \- **Automation hooks** – for fast deployment, sandbox testing, and environment setup.

By combining these, SWE agents can work **faster, smarter, and with fewer wasted resources**.
